<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://unpkg.com/primevue/umd/primevue.min.js"></script>

    <title>{{.title}} - PodGrab</title>
    {{template "commoncss" .}}

    <style>
      /* Base styles */
      body {
        margin: 0;
        padding: 0;
        font-family: "Open Sans", sans-serif;
      }

      /* Episode list styles */
      .episode-list {
        margin-bottom: 100px; /* Space for the player */
      }

      .episode {
        display: flex;
        padding: 15px;
        border-bottom: 1px solid #eee;
        cursor: pointer;
        transition: background-color 0.2s;
      }

      .episode:hover {
        background-color: #f5f5f5;
      }

      .episode.active {
        background-color: #e6f7ff;
      }

      .episode-image {
        width: 60px;
        height: 60px;
        border-radius: 4px;
        margin-right: 15px;
        background-size: cover;
        background-position: center;
        flex-shrink: 0;
      }

      .episode-details {
        flex-grow: 1;
      }

      .episode-title {
        font-weight: bold;
        margin-bottom: 5px;
      }

      .episode-podcast {
        font-size: 14px;
        font-weight: 600;
        color: #555;
      }

      .episode-date {
        font-size: 12px;
        color: #777;
      }

      .episode-duration {
        flex-shrink: 0;
        font-size: 14px;
        color: #777;
        align-self: center;
        margin-left: 10px;
      }

      /* Fixed player styles */
      .fixed-player {
        display: none;
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        z-index: 1000;
        background: var(--background);
        box-shadow: 0 -4px 16px rgba(0, 0, 0, 0.15);
        padding: 15px;
        display: grid;
        grid-template-columns: 1fr 2fr 1fr;
        gap: 20px;
        height: 90px;
      }

      .player-show {
        display: grid;
      }

      .player-left {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .player-image {
        height: 60px;
        width: 60px;
        border-radius: 4px;
        background-size: cover;
        background-position: center;
        position: relative;
      }

      .player-image-overlay {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        background: rgba(0, 0, 0, 0.5);
        opacity: 0;
        transition: opacity 0.2s;
        cursor: pointer;
        border-radius: 4px;
      }

      .player-image-overlay:hover {
        opacity: 1;
      }

      .player-details {
        overflow: hidden;
      }

      .player-title {
        font-weight: bold;
        font-size: 14px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .player-podcast {
        font-size: 12px;
        color: #555;
      }

      .player-center {
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }

      .player-controls {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 15px;
      }

      .player-timeline {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .player-time {
        font-size: 12px;
        color: #555;
        width: 60px;
        text-align: center;
      }

      .progress-container {
        flex-grow: 1;
        height: 4px;
        background-color: #ddd;
        position: relative;
        cursor: pointer;
        border-radius: 2px;
      }

      .progress-bar {
        position: absolute;
        left: 0;
        top: 0;
        height: 100%;
        background-color: #00a0ff;
        border-radius: 2px;
      }

      .progress-handle {
        position: absolute;
        right: -6px;
        top: -4px;
        width: 12px;
        height: 12px;
        background-color: #00a0ff;
        border-radius: 50%;
      }

      .player-right {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .volume-container {
        flex-grow: 1;
        height: 4px;
        background-color: #ddd;
        position: relative;
        cursor: pointer;
        border-radius: 2px;
      }

      .volume-bar {
        position: absolute;
        left: 0;
        top: 0;
        height: 100%;
        background-color: #00a0ff;
        border-radius: 2px;
      }

      .volume-handle {
        position: absolute;
        right: -6px;
        top: -4px;
        width: 12px;
        height: 12px;
        background-color: #00a0ff;
        border-radius: 50%;
      }

      .volume-percentage {
        font-size: 12px;
        color: #555;
        width: 40px;
        text-align: center;
      }

      .control-button {
        background: none;
        border: none;
        cursor: pointer;
        color: #555;
        font-size: 18px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: color 0.2s, transform 0.1s;
        padding: 5px;
      }

      .control-button:hover {
        color: #00a0ff;
      }

      .control-button:active {
        transform: scale(0.9);
      }

      .play-button {
        background-color: #00a0ff;
        color: white;
        width: 40px;
        height: 40px;
        border-radius: 50%;
      }

      .play-button:hover {
        background-color: #0088e0;
        color: white;
      }

      .speed-button {
        font-size: 14px;
        font-weight: bold;
        width: 30px;
        text-align: center;
      }

      /* Media queries for responsive design */
      @media (max-width: 768px) {
        .fixed-player {
          grid-template-columns: 1fr 2fr;
        }

        .player-right {
          display: none;
        }
      }

      @media (max-width: 576px) {
        .fixed-player {
          height: auto;
          padding: 10px;
          grid-template-columns: 1fr;
          gap: 10px;
        }

        .player-left {
          justify-content: center;
        }

        .player-center {
          order: -1;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      {{template "navbar" .}}

      <br />{{$setting := .setting}}
      <div id="app" v-cloak>
        <!-- Episode List -->
        <div class="episode-list">
          <div
            v-for="(item, index) in allItems"
            :key="item.ID"
            class="episode"
            :class="{ 'active': currentSongIndex === index }"
            @click="playSong(index)"
          >
            <div
              class="episode-image"
              :style="{ backgroundImage: `url(${getPodcastImage(item)})` }"
            ></div>
            <div class="episode-details">
              <div class="episode-title">${item.Title}</div>
              <div class="episode-podcast">${item.Podcast.Title}</div>
              <div class="episode-date">
                ${getFormattedLastEpisodeDate(item)}
              </div>
            </div>
            <div class="episode-duration">${formatDuration(item.Duration)}</div>
          </div>

          <div v-if="isLoading" class="loading-more">
            Loading more episodes...
          </div>
        </div>

        <!-- Fixed Player -->
        <div class="fixed-player" :class="{ 'player-show': isPlayerVisible }">
          <!-- Left section: Image and Title -->
          <div class="player-left">
            <div
              class="player-image"
              :style="{ backgroundImage: `url(${currentSong ? (currentSong.cover_art_url || '') : ''})` }"
            >
              <div class="player-image-overlay">
                <span style="color: white">â›¶</span>
              </div>
            </div>
            <div class="player-details">
              <div class="player-title">
                ${currentSong ? currentSong.name : ''}
              </div>
              <div class="player-podcast">
                ${currentSong ? currentSong.artist : ''}
              </div>
            </div>
          </div>

          <!-- Center section: Controls and Timeline -->
          <div class="player-center">
            <div class="player-controls">
              <div
                class="control-button"
                @click="replayThirty"
                title="Replay 30 seconds"
              >
                <span>-30</span>
              </div>
              <div
                class="control-button"
                id="previous"
                @click="prevSong"
                title="Previous track"
              ></div>
              <div
                class="control-button"
                id="play-pause"
                :class="isPlaying ? 'amplitude-playing' : 'amplitude-paused'"
                @click="togglePlay"
                title="Play/Pause"
              ></div>
              <div
                class="control-button"
                id="next"
                @click="nextSong"
                title="Next track"
              ></div>
              <div
                class="control-button"
                @click="forwardThirty"
                title="Forward 30 seconds"
              >
                <span>+30</span>
              </div>
              <div
                class="control-button speed-button"
                @click="changeSpeed"
                title="Change playback speed"
              >
                ${speed}x
              </div>
            </div>

            <div class="player-timeline">
              <div class="player-time">${formatTime(currentTime)}</div>
              <div class="progress-container" @click="seekTo">
                <div
                  class="progress-bar"
                  :style="{ width: `${playedPercentage}%` }"
                >
                  <div class="progress-handle"></div>
                </div>
              </div>
              <div class="player-time">${formatTime(duration)}</div>
            </div>
          </div>

          <!-- Right section: Volume controls -->
          <div class="player-right">
            <div
              class="amplitude-mute control-button"
              :class="isMuted ? 'amplitude-muted' : 'amplitude-not-muted'"
              @click="toggleMute"
              title="Mute/Unmute"
            ></div>

            <div class="volume-container" @click="changeVolume">
              <div class="volume-bar" :style="{ width: `${volume}%` }">
                <div class="volume-handle"></div>
              </div>
            </div>

            <div class="volume-percentage">${volume}%</div>
          </div>
        </div>
      </div>
    </div>

    {{template "scripts"}}
    <script src="/webassets/amplitude.min.js"></script>

    <script>
      var app = new Vue({
        delimiters: ["${", "}"],
        el: "#app",
        data: {
          speed: 1,
          speedOptions: [0.75, 1, 1.1, 1.25, 1.5, 1.75, 2, 2.5, 3],
          songLoaded: [],
          socket: null,
          allItems: {{ .podcastItems }},
          isPlayerVisible: false,
          currentSongIndex: -1,
          isPlaying: false,
          isMuted: false,
          volume: 50,
          currentTime: 0,
          duration: 0,
          playedPercentage: 0,
          isLoading: false,
          loadingMore: false,
          page: 1,
          markedAsPlayed: []
        },
        computed: {
          songs() {
            return this.getSongsFromItems(this.allItems);
          },
          currentSong() {
            if (this.currentSongIndex >= 0 && this.songs.length > this.currentSongIndex) {
              return this.songs[this.currentSongIndex];
            }
            return null;
          }
        },
        watch: {
          speed(newSpeed) {
            Amplitude.setPlaybackSpeed(newSpeed);
            if (localStorage) {
              localStorage.speed = newSpeed;
            }
          }
        },
        created() {
          const self = this;
          this.socket = getWebsocketConnection(
            function(event) {
              const message = getWebsocketMessage("RegisterPlayer", "");
              self.socket.send(message);
            },
            x => {
              if (!x.data) {
                return;
              }
              payload = JSON.parse(x.data);
              if (payload.messageType == "Enqueue") {
                newItems = JSON.parse(payload.payload);
                newItems.forEach(x => { this.allItems.push(x) });
                newSongs = self.getSongsFromItems(newItems);
                newSongs.forEach(x => { Amplitude.addSong(x) });
              }
            }
          );

          // Check localStorage for previously played items
          if (localStorage && localStorage.songTimes) {
            const songTimes = JSON.parse(localStorage.songTimes);
            if (Object.keys(songTimes).length > 0) {
              this.isPlayerVisible = true;
            }
          }

          // Add scroll event listener for infinite scroll
          window.addEventListener('scroll', this.handleScroll);
        },
        beforeDestroy() {
          window.removeEventListener('scroll', this.handleScroll);
        },
        mounted() {
          var volume = 50;
          if (localStorage && localStorage.playerVolume) {
            volume = parseInt(localStorage.playerVolume);
            this.volume = volume;
          }

          const self = this;
          Amplitude.init({
            "songs": this.songs,
            "start_song": 0,
            "volume": volume,
            "callbacks": {
              'play': function() {
                self.isPlaying = true;
                self.isPlayerVisible = true;
              },
              'pause': function() {
                self.isPlaying = false;
              },
              'timeupdate': function() {
                const secs = Math.floor(Amplitude.getSongPlayedSeconds());
                self.currentTime = secs;
                self.duration = Amplitude.getSongDuration();
                self.playedPercentage = Amplitude.getSongPlayedPercentage();

                if (secs % 10 === 0) {
                  const song = Amplitude.getActiveSongMetadata();
                  if (Amplitude.getSongPlayedPercentage() > 20) {
                    self.markSongAsPlayed(song.id);
                  }
                  if (Amplitude.getSongPlayedPercentage() > 95) {
                    self.removeSongTime(song.id);
                  } else {
                    self.saveSongTime(song.id, secs);
                  }
                }
              },
              'song_change': function() {
                self.currentSongIndex = Amplitude.getActiveIndex();

                if (localStorage && localStorage.playerVolume) {
                  volume = parseInt(localStorage.playerVolume);
                  Amplitude.setVolume(volume);
                }

                // Get saved time for the song
                const time = self.getSavedSongTime();
                if (time > 0) {
                  Amplitude.skipTo(time, self.currentSongIndex);
                }
              },
              'volumechange': function() {
                volume = Amplitude.getVolume();
                self.volume = volume;
                if (localStorage) {
                  localStorage.playerVolume = volume.toString();
                }
              },
              'initialized': function() {
                if (localStorage && localStorage.speed) {
                  self.speed = parseFloat(localStorage.speed);
                }
              }
            }
          });
        },
        methods: {
          handleScroll() {
            if (this.isLoading || this.loadingMore) return;

            const scrollHeight = document.documentElement.scrollHeight;
            const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
            const clientHeight = document.documentElement.clientHeight;

            if (scrollTop + clientHeight >= scrollHeight - 200) {
              this.loadMoreItems();
            }
          },
          loadMoreItems() {
            this.isLoading = true;
            this.page += 1;

            const self = this; // Store reference to component

            axios
              .get(encodeURI("/player/more?page=" + this.page))
              .then(function(response) {
                // Use the stored reference
                if (response.data && response.data.podcastItems) {
                  self.allItems = [...self.allItems, ...response.data.podcastItems];

                  // Also add the new songs to Amplitude player
                  const newSongs = self.getSongsFromItems(response.data.podcastItems);
                  newSongs.forEach(song => Amplitude.addSong(song));
                }
              })
              .catch(function(error) {
                console.error("Error loading more items:", error);
              })
              .finally(function() {
                // Set loading state back to false
                self.isLoading = false;
              });
          },
          getPodcastImage(episode){
            return "/podcasts/"+String(episode.Podcast.ID)+"/image"
          },
          playSong(index) {
            Amplitude.playSongAtIndex(index);
            this.currentSongIndex = index;
            this.isPlayerVisible = true;
            this.isPlaying = true;
          },
          togglePlay() {
            if (this.isPlaying) {
              Amplitude.pause();
            } else {
              Amplitude.play();
            }
            this.isPlaying = !this.isPlaying;
          },
          prevSong() {
            Amplitude.prev();
          },
          nextSong() {
            Amplitude.next();
          },
          replayThirty() {
            const newTime = Math.max(0, this.currentTime - 30);
            Amplitude.skipTo(newTime, this.currentSongIndex);
          },
          forwardThirty() {
            const newTime = Math.min(this.duration, this.currentTime + 30);
            Amplitude.skipTo(newTime, this.currentSongIndex);
          },
          seekTo(event) {
            const container = event.currentTarget;
            const containerWidth = container.clientWidth;
            const clickPosition = event.offsetX;
            const percentage = (clickPosition / containerWidth) * 100;
            const newTime = (percentage / 100) * this.duration;

            Amplitude.skipTo(newTime, this.currentSongIndex);
          },
          toggleMute() {
            if (this.isMuted) {
              Amplitude.setVolume(this.volume);
            } else {
              Amplitude.setVolume(0);
            }
            this.isMuted = !this.isMuted;
          },
          changeVolume(event) {
            const container = event.currentTarget;
            const containerWidth = container.clientWidth;
            const clickPosition = event.offsetX;
            const newVolume = Math.round((clickPosition / containerWidth) * 100);

            this.volume = newVolume;
            Amplitude.setVolume(newVolume);
            this.isMuted = (newVolume === 0);
          },
          changeSpeed() {
            const currentSpeedIndex = this.speedOptions.indexOf(this.speed);
            const nextIndex = (currentSpeedIndex === -1 || currentSpeedIndex === this.speedOptions.length - 1) ? 0 : currentSpeedIndex + 1;
            this.speed = this.speedOptions[nextIndex];
          },
          formatTime(seconds) {
            if (!seconds) return "00:00";

            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);

            if (hours > 0) {
              return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
          },
          getSongsFromItems(items) {
            return items.map(x => {
              var image = "/podcasts/" + x.Podcast.ID + "/image"
              var toReturn = {
                id: x.ID,
                name: x.Title,
                url: "/podcastitems/" + x.ID + "/file",
                cover_art_url: image,
                artist: x.Podcast.Title,
                summary: x.Summary,
                album: new Date(x.PubDate.substr(0, 10)).toDateString()
              };
              if (!toReturn.url) {
                toReturn.url = x.FileURL;
              }
              return toReturn;
            });
          },
          getFormattedLastEpisodeDate(item) {
            var dt = new Date(Date.parse(item.PubDate.substr(0, 10)));
            return dt.toDateString();
          },
          formatDuration(total) {
            if (total <= 0) {
              return "";
            }
            var mins = Math.floor(total / 60);
            var secs = Math.floor(total % 60);
            var hrs = 0;
            if (mins >= 60) {
              hrs = Math.floor(mins / 60);
              mins = mins % 60;
            }

            if (hrs > 0) {
              return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            return `${mins}:${secs.toString().padStart(2, '0')}`;
          },
          removeSongTime(songId) {
            if (localStorage) {
              var songTimes = localStorage.songTimes;
              if (!songTimes) {
                songTimes = {};
              } else {
                songTimes = JSON.parse(localStorage.songTimes);
              }
              if (songTimes.hasOwnProperty(songId)) {
                delete songTimes[songId];
                localStorage.songTimes = JSON.stringify(songTimes);
              }
            }
          },
          saveSongTime(songId, time) {
            if (localStorage) {
              var songTimes = localStorage.songTimes;
              if (!songTimes) {
                songTimes = {};
              } else {
                songTimes = JSON.parse(localStorage.songTimes);
              }
              songTimes[songId] = time;
              localStorage.songTimes = JSON.stringify(songTimes);
            }
          },
          getSavedSongTime() {
            if (localStorage) {
              var song = Amplitude.getActiveSongMetadata();
              var songTimes = localStorage.songTimes;
              if (!songTimes) {
                songTimes = {};
              } else {
                songTimes = JSON.parse(localStorage.songTimes);
              }
              if (songTimes.hasOwnProperty(song.id)) {
                return songTimes[song.id];
              }
            }
            return 0;
          },
          markSongAsPlayed(id) {
            if (this.markedAsPlayed.indexOf(id) !== -1) {
              return;
            }
            this.markedAsPlayed.push(id);
            axios
              .get("/podcastitems/" + id + "/markPlayed", {
                isPlayed: true,
              })
              .then(function(response) {})
              .catch(function(error) {})
              .then(function() {});
            return false;
          }
        }
      });
    </script>
  </body>
</html>
